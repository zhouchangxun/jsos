<!DOCTYPE html>
<html>
<head>
  <style>
    .container { margin: 20px; font-family: Arial, sans-serif; }
    .control-group { margin: 15px 0; }
    button { 
      padding: 8px 16px; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      margin-right: 10px;
      font-size: 14px;
    }
    #abortAllBtn { background: #dc2626; color: white; }
    #abortPidBtn { background: #f59e0b; color: white; }
    input { padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-right: 10px; }
    #log { 
      margin-top: 20px; 
      padding: 15px; 
      background: #f9fafb; 
      border-radius: 4px; 
      height: 350px; 
      overflow-y: auto;
      font-size: 14px;
    }
    .log-item { margin: 6px 0; line-height: 1.6; }
    .task { color: #1e40af; }
    .cleanup { color: #166534; font-style: italic; }
    .system { color: #dc2626; font-weight: 500; }
    .success { color: #059669; }
  </style>
</head>
<body>
  <div class="container">
    <h3>任务PID中断管理器（修复收尾重复触发）</h3>
    <div class="control-group">
      <button id="startTaskBtn">启动新任务（自动分配PID）</button>
      <button id="abortAllBtn">中断所有任务</button>
    </div>
    <div class="control-group">
      <input type="number" id="pidInput" placeholder="输入PID">
      <button id="abortPidBtn">中断指定PID任务</button>
    </div>
    <div id="log"></div>
  </div>

  <script>
    // 1. 核心：任务注册表 + 全局中断控制器（新增监听函数存储，用于精准移除）
    const taskRegistry = new Map(); // key: PID, value: { controller, cleanupFns, listeners: {} }
    let nextPid = 1;
    const globalAbortController = new AbortController();
    const globalListeners = new Set(); // 存储全局信号监听函数，避免重复

    // 2. 工具函数：打印日志
    const log = (content, type = 'default') => {
      const logEl = document.getElementById('log');
      const className = `log-item ${type}`;
      const time = new Date().toLocaleTimeString();
      logEl.innerHTML += `<div class="${className}">[${time}] ${content}</div>`;
      logEl.scrollTop = logEl.scrollHeight;
    };

    // 3. 生成唯一PID
    const generatePid = () => {
      const pid = nextPid;
      nextPid++;
      return pid;
    };

    // 4. 核心修复：withSignalPid（精准清理监听 + 防止收尾重复执行）
    const withSignalPid = (pid, taskPromise, cleanupFn) => {
      const taskEntry = taskRegistry.get(pid);
      if (!taskEntry) throw new Error(`PID ${pid} 任务不存在`);

      // 注册收尾函数（确保同一函数不重复注册）
      let isCleanupRegistered = false;
      if (typeof cleanupFn === 'function' && !taskEntry.cleanupFns.has(cleanupFn)) {
        taskEntry.cleanupFns.add(cleanupFn);
        isCleanupRegistered = true;
      }

      // -------------------------- 修复点1：PID信号监听函数加唯一标识 --------------------------
      const handlePidAbort = () => {
        // 执行收尾函数（仅执行一次）
        if (taskEntry.cleanupFns.size > 0) {
          taskEntry.cleanupFns.forEach(cb => {
            try { cb(pid); } catch (err) { log(`PID ${pid} 收尾函数出错：${err.message}`, 'system'); }
          });
          taskEntry.cleanupFns.clear(); // 执行后立即清空，避免重复触发
        }
        // 精准移除监听（关键：用存储的函数引用）
        taskEntry.controller.signal.removeEventListener('abort', handlePidAbort);
        delete taskEntry.listeners.pid; // 从任务Entry移除监听引用
        reject(new Error(`PID ${pid} 任务被指定中断`));
      };
      // 存储监听函数引用，用于后续移除
      taskEntry.listeners.pid = handlePidAbort;

      // 处理已中断状态
      if (taskEntry.controller.signal.aborted) {
        handlePidAbort();
        return new Promise((_, reject) => reject(new Error(`PID ${pid} 任务已中断`)));
      }
      taskEntry.controller.signal.addEventListener('abort', handlePidAbort);

      // -------------------------- 修复点2：全局信号监听函数加唯一标识 --------------------------
      const handleGlobalAbort = () => {
        // 执行收尾函数（仅执行一次）
        if (taskEntry.cleanupFns.size > 0) {
          taskEntry.cleanupFns.forEach(cb => {
            try { cb(pid); } catch (err) { log(`PID ${pid} 全局中断收尾出错：${err.message}`, 'system'); }
          });
          taskEntry.cleanupFns.clear(); // 执行后立即清空
        }
        // 精准移除监听
        globalAbortController.signal.removeEventListener('abort', handleGlobalAbort);
        globalListeners.delete(handleGlobalAbort); // 从全局集合移除
        delete taskEntry.listeners.global;
        reject(new Error(`PID ${pid} 任务被全局中断`));
      };
      // 存储监听函数引用
      taskEntry.listeners.global = handleGlobalAbort;
      globalListeners.add(handleGlobalAbort);

      // 处理已中断状态
      if (globalAbortController.signal.aborted) {
        handleGlobalAbort();
        return new Promise((_, reject) => reject(new Error(`PID ${pid} 任务已被全局中断`)));
      }
      globalAbortController.signal.addEventListener('abort', handleGlobalAbort);

      // 竞速逻辑
      return new Promise((resolve, reject) => {
        Promise.race([
          taskPromise.then(resolve).catch(reject),
          new Promise((_, pidReject) => { taskEntry.listeners.pid = pidReject; }), // 关联PID中断reject
          new Promise((_, globalReject) => { taskEntry.listeners.global = globalReject; }) // 关联全局中断reject
        ])
        .finally(() => {
          // 任务正常完成：清理所有资源
          if (isCleanupRegistered) taskEntry.cleanupFns.delete(cleanupFn);
          // 强制移除监听（双重保障）
          if (taskEntry.listeners.pid) {
            taskEntry.controller.signal.removeEventListener('abort', taskEntry.listeners.pid);
            delete taskEntry.listeners.pid;
          }
          if (taskEntry.listeners.global) {
            globalAbortController.signal.removeEventListener('abort', taskEntry.listeners.global);
            globalListeners.delete(taskEntry.listeners.global);
            delete taskEntry.listeners.global;
          }
        });
      });
    };

    // 5. 任务工厂：创建带循环逻辑的异步任务（初始化时新增listeners对象）
    const createTask = async () => {
      const pid = generatePid();
      // 修复点3：任务Entry新增listeners对象，存储监听函数引用
      taskRegistry.set(pid, {
        controller: new AbortController(),
        cleanupFns: new Set(),
        listeners: {} // 用于存储当前任务的所有信号监听函数
      });

      // 任务专属收尾函数（仅执行一次）
      const taskCleanup = (taskPid) => {
        clearTimeout(timer);
        taskRegistry.delete(taskPid);
        log(`PID ${taskPid} 收尾完成：清理定时器 + 移除注册表`, 'cleanup');
      };

      log(`PID ${pid} 任务启动：每1.2秒打印一次（共8次）`, 'task');
      let timer = null;
      let count = 1;

      try {
        while (count <= 8) {
          await withSignalPid(
            pid,
            new Promise(resolve => { timer = setTimeout(resolve, 1200); }),
            taskCleanup
          );
          log(`PID ${pid} 任务进度：第 ${count} 次打印`, 'task');
          count++;
        }
        // 任务正常完成：执行收尾并清理
        taskCleanup(pid);
        log(`PID ${pid} 任务正常完成！`, 'success');
        return pid;
      } catch (err) {
        log(`PID ${pid} 任务终止：${err.message}`, 'system');
        throw err;
      }
    };

    // 6. 功能按钮事件绑定（无修改，保持原逻辑）
    document.getElementById('startTaskBtn').addEventListener('click', () => {
      createTask().catch(() => {});
    });

    document.getElementById('abortPidBtn').addEventListener('click', () => {
      const pid = Number(document.getElementById('pidInput').value);
      if (isNaN(pid) || pid < 1) {
        log('请输入有效的PID（正整数）', 'system');
        return;
      }

      const taskEntry = taskRegistry.get(pid);
      if (!taskEntry) {
        log(`PID ${pid} 任务不存在（已完成或未创建）`, 'system');
        return;
      }

      if (taskEntry.controller.signal.aborted) {
        log(`PID ${pid} 任务已处于中断状态`, 'system');
        return;
      }

      taskEntry.controller.abort();
      log(`已发送中断指令：PID ${pid}`, 'system');
    });

    document.getElementById('abortAllBtn').addEventListener('click', () => {
      if (globalAbortController.signal.aborted) {
        log('全局中断已触发，无需重复操作', 'system');
        return;
      }

      globalAbortController.abort();
      // 清空所有任务注册表和全局监听
      taskRegistry.clear();
      globalListeners.clear();
      log('已发送全局中断指令：所有任务将终止', 'system');
    });

    // 初始化提示
    log('=== 任务管理器初始化完成（已修复收尾重复触发） ===', 'success');
    log('操作指引：1. 启动新任务 2. 输入PID中断指定任务 3. 全局中断所有任务', 'success');
  </script>
</body>
</html>